---
title: java-摘要
date: 2019-06-18 20:13:13
tags: [笔记,计算机基础,java-摘要]
categories: [计算机基础,java-摘要]
keywords: [计算机基础,java-摘要]
description: 纯粹想到什么写什么，做个知识的总结
image: 
---



# java-摘要



## 2. 一切都是对象

- 特例：8个基本类型。Boolean,char,byte,short,int,long,float,double。创建的不是引用变量，而是**直接存储值于栈中**，因此效率更高。
- 创建数组对象，实际上创建了一个引用数组，初始值为null，需要逐个填入对象。创建基本类型数组则内存全部置零。
- 类的基本数据类型的成员变量会默认为0。而方法的局部变量则没有默认值。
- static，类数据类方法，实际上就是Java的全局变量、方法。



## 5. 初始化与清理

- 重载：每个**重载的方法必须有一个独一无二的参数类型列表。而不能靠返回值来区分，**因为可能方法调用者不关心返回值，没有接收返回值或用Object接收等等。

- 如果没定义构造器，则编译器会自动创建默认无参构造器；如果定义了，则不会再自动创建。
- this关键字表示**调用方法的那个对象的引用**。所以this只能在方法中使用；所以static方法不能用this。
- this关键字可以在构造器器中调用另一个构造器，来减少代码。但只能调用一个构造器，且调用语句需要写在第一句。
- finalize()方法用于对象被回收时做一些重要的清理工作，但尽量避免使用。
- 如果JVM并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收的。（详见Java垃圾回收单章）
- 无论创建多少个对象，静态数据都只占用一份存储区域。只有在第一次对象被创建或者第一次访问静态数据时，静态数据才会被初始化，之后不会再被初始化。
- 对象创建过程：
  - s



## 6. 访问权限控制

- .Java文件中的每个类都会有一个编译文件，所以一个.java文件会编译出多个.class文件。
- Java解释器的代码搜索过程：(详见Java编译器、解释器单章)
  - 找到环境变量classpath，包含一个或多个目录，用作查找.class文件的根目录。
  - 将包名的句号替换成反斜杠，与根目录组合，查找.class文件。
- 访问权限修饰词：
  - public：到处可以使用
  - 不写修饰词：包访问权限，包内可用。外部类继承还是不可用，包内继承则可用。
  - protected：包内可用。继承类之后，外部类也可用。 
  - private：只有类内部可用。
- 每个.java文件需要一个同名的外部类，这个类只能用public或默认修饰词。
- 可以将构造器设置成private，这样外部就无法创建该类对象。但可以用类的静态方法内部调用构造器形成**单例模式**。



## 7. 复用类

- 组合与继承
- **继承并不只是复制基类的接口。当创建一个导出类对象时，该对象会隐式的包含一个基类的子对象。super则指向这个对象。**
- Java会自动在导出类的构造器中插入对基类构造器的调用。如果想调用一个带参数的基类构造器，就必须用关键字super显式的调用，而且该调用必须写在最前面。
- 使用@Override注解确保是重写操作。
- 如果不是必须向上转型，则最好用组合。继承的优势只在于向上转型。
- final数据，初始化之后就不能再改变。如果是基本类型则数值不变，如果是对象引用则引用不变，但对象内容可变。
- final方法，防止继承修改方法。实际上private方法都隐式的指定为final。
- final类，拒绝继承。
- 类在其任何static成员被访问时进行加载，因为构造器也是static方法。
- 在子类被加载前会先加载其父类，以保证父类可用。



## 8. 多态

- 向上转型是一定安全的。向下转型则不安全，如果类型不符则会报异常。
- 多态通过动态绑定进行实现。
- 子类中可以有父类中的private方法，不过并不是重新。
- **只有普通方法的调用可以是多态的。**（可以理解为向上转型只会覆盖方法，而父类和子类的变量都会存在）
  - 变量是没有多态的。出现和父类同名的public变量会很容易混淆，直接通过.变量获得值会发现向上转型后返回的值是父类的值而用get方法获得的值是子类的值！所以一般会将所有的域设置为private，通过调用方法来获得，而且一般不要取同名。
  - 静态方法没有多态。因为静态方法是和类绑定的而不是和对象。所以如果父类和子类有同名静态方法，向上转型后则会调用父类的方法。



## 9. 接口

- 包含抽象方法的类叫做**抽象类**，abstract。
- interface是一个极度抽象的类，允许通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承的特性。
- 接口可以包含变量，但这些变量只能是static final的。
- 接口的方法只能是public的。
- **使用接口的核心原因：为了能够向上转型为多个基类（类似多继承），并防止被直接创建（类似抽象类）。**
- 可以通过继承extends来扩展接口。
- 工厂模式通过接口实现。工厂模式实际上就是将多个实现了同一个接口的类进行封装形成factory，使用时工程类根据提供的字符串或其他信息返回相应对象的向上转型对象，使得用户不用知道具体的类名和实现。比如数据库的方言、驱动。



## 10. 内部类

- **内部类自动拥有对外围类所有成员的访问权！**在创建一个内部类时，内部类会秘密捕获一个指向外围类对象的引用。
- 可以在内部类中实现接口，然后返回向上转型的接口引用。这样能够隐藏接口的实现。
- 在方法中的内部类称为局部内部类。
- **匿名内部类，必须继承一个父类或实现一个接口**，匿名内部类能够简化代码编写。

```java
interface Person {
    public void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() { //匿名内部类返回的是接口或者抽象类的引用
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
```

- 嵌套类，static的类，与外围类对象之间没有联系。
- **内部类最大的优势：**每个内部类都能独立的继承实现接口抽象类，而不需要外围类来继承实现，变相的实现了多继承。另外内部类的使用是为了辅助解决一些复杂问题，但又不希望暴露这个类。



## 11. 持有对象

- HashMap、TreeMap(按值升序)、LinkedHashMap(按插入顺序)。
- ArrayList优于访问，LinkedList优于插入删除。



## 12. 异常处理

- throw
- try/catch/finally



## 13. 字符串

详见单章



## 14. 类信息

见单章



































































