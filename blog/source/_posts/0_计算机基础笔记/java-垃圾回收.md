---
title: java-垃圾回收
date: 2019-06-18 20:13:13
tags: [笔记,计算机基础,java-垃圾回收]
categories: [计算机基础,java-垃圾回收]
keywords: [计算机基础,java-垃圾回收]
description: 纯粹想到什么写什么，做个知识的总结
image: 
---



# java-垃圾回收

转载[Sunnier](https://www.cnblogs.com/sunniest/)

垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，**Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。**

Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：**（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。**　　

## 发现无用信息对象

###1. 引用计数法

　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

优点：
引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点： 
无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

### 2. 可达性分析法

　　根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

java中可作为GC Root的对象有(就是所有栈和静态存储区的引用)

　　1.虚拟机栈中引用的对象（本地变量表）

　　2.方法区中静态属性引用的对象

　　3. 方法区中常量引用的对象

　　4.本地方法栈中引用的对象（Native对象）

优点：解决循环依赖，不会有对象遗漏。

缺点：速度比较慢，一般要等到内存满了才清理。需要中断程序



## 回收无用信息对象

### 1. 标记-清除

就是简单的将无用对象进行回收。但是会造成内存碎片不可取。

### 2. 复制算法

![](/java-垃圾回收/1.jpg)

　　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。

优点：没有内存碎片，速度相对较快。

缺点：需要额外的内存空间。当程序比较稳定时，可能只有少量垃圾，这时候复制算法很浪费。

### 3. 标记-整理算法

![](/java-垃圾回收/2.jpg)

　　在清除时，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，成本高，但解决了内存碎片的问题。

优点：没有内存碎片。不需要额外内存空间。对于比较稳定的程序，即垃圾较少的情况效果比较好。

缺点：在一般的情况下，速度相当的慢。

### 4. generation算法

![](/java-垃圾回收/3.jpg)

　　分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。**简单来说就是对于生命周期短的对象使用复制策略，对于生命周期长的对象使用标记-整理的策略。**

**● 年轻代（Young Generation）**

　　1.年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般是新生的不大的对象。

　　2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(from,to)区。大部分对象在Eden区中生成(**大对象直接进入年老代**)。当Eden区满时，将From区和Eden区的存活对象复制到To区，然后将From区和To区交换，即保持To区为空， 如此往复。

　　3.当To区不足以存放 eden和From的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。

　　4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)

为什么需要survivor区？：实际上这是一个缓冲区，减少被送到老年代的对象，只有经过多次Minor GC还存活的对象才有资格进入老年代。

为什么设置两个survivor区？：因为进行复制算法需要额外的内存空间支持，所以实际上survivor-from区当做缓冲区，survivor-to区用于支持复制算法。这样就能保证from区是无碎片的，to区是空的。

为什么不多设计几个survivor区？：没必要，还会导致survivor区太小容易满。

**● 年老代（Old Generation）**

　　1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

　　2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。

进入年老代的特殊情况：1.大对象，所以如果系统有大量短周期的大对象时要注意了。2.在年轻代经历了15次Minor GC的对象。3.如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区。

**● 持久代（Permanent Generation）**

　　处于方法区，用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。



## Java内存泄露问题

- 静态集合类最容易出现内存泄露，因为是静态类不会被GC释放，随着集合越来越大造成内存泄露。
- 各种连接，数据库连接，网络连接，IO连接等没有关闭，未被GC回收导致内存泄露。
- 监听器的使用，在释放对象后没有删除相应的监听器也可能导致内存泄露。







